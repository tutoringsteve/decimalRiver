package com.company;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.Random;

/**
 * Generates what appears to be a flowing ascii river using a few parameters
 * The land are the 0's on the left and right and the river is the numbers
 * in the interior.
 */
public class Main {

    //how long each print to console waits in milliseconds before printing, basically controls the speed of flow
    private static int speed = 250;
    //precision is the width of the river + land (how many digits wide the river and land are)
    private static int riverWidth = 160;
    //will start the flow with a seed of 0.baseI, lower numbers create thinner rivers
    private static int riverSeed = 105;
    //controls how long the program should run for, each cycle adds another row to the river up to the max.
    private static int maxRiverLength = 1000;

    public static void main(String[] args) throws InterruptedException {

        //creates the initial river state
        BigDecimal bd = bigDecimalBase(riverSeed, riverWidth);

        int power = 1;
        Random random = new Random();
        for(int riverLength = 1; riverLength <= maxRiverLength; riverLength++) {
            //If the river is to close to the left, keep moving it right
            if(power <= 10) {
                while(power < 30) {
                    System.out.println(flowRiver(bd, power++));
                }
            //If the river is to close to the right, keep moving it left
            //todo: Base the boundary values in this conditional off some value less than the max power that will print all 0's
            } else if(power >= 80) {
                while(power > 60) {
                    System.out.println(flowRiver(bd, power--));
                }
            } else {

                //how many times in a row the river will move left or right
                //choose a direction and then move that direction between 3 and 6 times
                //when it was just move randomly left or right the river would look stuck too often
                int max = random.nextInt(3)+3;

                if(random.nextBoolean()) {
                    for(int i = 1; i <= max; i++) {
                        System.out.println(flowRiver(bd, power++));
                    }
                } else {
                    for(int i = 1; i <= max; i++) {
                        System.out.println(flowRiver(bd, power--));
                    }
                }
                System.out.println(flowRiver(bd, power));
            }

        }
    }

    /**
     * Pads the input String with the pad String n times on the right side and returns it.
     * @param s the input String before padding
     * @param n the number of times to pad the pad String to the right side of s
     * @param pad the String to pad to s
     * @return the string s + pad + pad + pad +... + pad, where pad is added n times.
     */
    private static String rightPad(String s, int n, String pad) {
        if(n < 1) {
            return s;
        }

        StringBuilder sb = new StringBuilder(s);

        for(int i = 1; i <= n; i++) {
            sb.append(pad);
        }

        return sb.toString();
    }

    /**
     Creates a bigDecimal with a desired precision and a given integer value to immediately
     follow the decimal.

     Since you cannot perfectly represent 0.1 as a binary decimal, simply constructing a large
     precision decimal from something like 0.36 using BigDecimal will result in a value like
     0.3599999999999999723984390239843... for example. So to get a 0.3600000000....000 we need
     to first construct a string with "0." + an integer base (baseI) + as many 0's as we need to
     reach a decimal with the desired precision.

     @param baseI Will be used to create a decimal 0.baseI
     @param precision How many digits will be shown
     **/
    private static BigDecimal bigDecimalBase(Integer baseI, int precision) {
        String baseS = baseI.toString();
        String base = rightPad("0." + baseS, precision - baseS.length(), "0");
        MathContext mc = new MathContext(precision);
        BigDecimal bd = new BigDecimal(base, mc);
        return bd;
    }

    /**
     * Generates a String for the next cycle of the river
     * @param bd the original big decimal, likely generated by bigDecimalBase(riverSeed, riverWidth)
     * @param power the power to raise the original big decimal too, which moves the river right for increasing powers
     *              and moves the river left for decreasing powers
     * @return returns the String for the next cycle of the river, a line of text with riverWidth digits after the
     * decimal
     * @throws InterruptedException Unhandled exception suggested in combination with Thread.sleep
     */
    private static String flowRiver(BigDecimal bd, int power) throws InterruptedException {
        Thread.sleep(speed);
        return bd.pow(power, new MathContext(riverWidth)).toPlainString().substring(0,riverWidth+2);

    }
}
